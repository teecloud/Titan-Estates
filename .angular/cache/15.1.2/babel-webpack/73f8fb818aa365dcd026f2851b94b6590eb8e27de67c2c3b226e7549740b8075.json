{"ast":null,"code":"import { PLATFORM_ID } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { map } from 'rxjs/operators';\nimport { isPlatformServer } from '@angular/common';\nimport { DataStore } from '../shell/data-store';\nimport { TransferStateHelper } from '../utils/transfer-state-helper';\nimport { FashionListingModel } from './listing/fashion-listing.model';\nimport { FashionDetailsModel } from './details/fashion-details.model';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../utils/transfer-state-helper\";\nimport * as i2 from \"@angular/common/http\";\nexport class FashionService {\n  constructor(platformId, transferStateHelper, http) {\n    this.platformId = platformId;\n    this.transferStateHelper = transferStateHelper;\n    this.http = http;\n  }\n  getListingDataSource() {\n    const rawDataSource = this.http.get('./assets/sample-data/fashion/listing.json').pipe(map(data => {\n      // Note: HttpClient cannot know how to instantiate a class for the returned data\n      // We need to properly cast types from json data\n      const listing = new FashionListingModel();\n      // The Object.assign() method copies all enumerable own properties from one or more source objects to a target object.\n      // Note: If you have non-enummerable properties, you can try a spread operator instead. listing = {...data};\n      // (see: https://scotch.io/bar-talk/copying-objects-in-javascript#toc-using-spread-elements-)\n      Object.assign(listing, data);\n      return listing;\n    }));\n    // This method tapps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState('fashion-listing-state', rawDataSource);\n    return cachedDataSource;\n  }\n  getListingStore(dataSource) {\n    // Check if we already loaded this object\n    if (!this.listingDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel = new FashionListingModel();\n      this.listingDataStore = new DataStore(shellModel);\n      // If running in the server, then don't add shell to the Data Store\n      // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the broswer from the server\n      if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n        // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n        this.listingDataStore.load(dataSource, 0);\n      } else {\n        // On browser transitions\n        // Trigger the loading mechanism (with shell)\n        this.listingDataStore.load(dataSource);\n      }\n    }\n    return this.listingDataStore;\n  }\n  getDetailsDataSource() {\n    const rawDataSource = this.http.get('./assets/sample-data/fashion/details.json').pipe(map(data => {\n      // Note: HttpClient cannot know how to instantiate a class for the returned data\n      // We need to properly cast types from json data\n      const details = new FashionDetailsModel();\n      // The Object.assign() method copies all enumerable own properties from one or more source objects to a target object.\n      // Note: If you have non-enummerable properties, you can try a spread operator instead. details = {...data};\n      // (see: https://scotch.io/bar-talk/copying-objects-in-javascript#toc-using-spread-elements-)\n      Object.assign(details, data);\n      return details;\n    }));\n    // This method tapps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState('fashion-details-state', rawDataSource);\n    return cachedDataSource;\n  }\n  getDetailsStore(dataSource) {\n    // Check if we already loaded this object\n    if (!this.detailsDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel = new FashionDetailsModel();\n      this.detailsDataStore = new DataStore(shellModel);\n      // If running in the server, then don't add shell to the Data Store\n      // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the broswer from the server\n      if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n        // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n        this.detailsDataStore.load(dataSource, 0);\n      } else {\n        // On browser transitions\n        // Trigger the loading mechanism (with shell)\n        this.detailsDataStore.load(dataSource);\n      }\n    }\n    return this.detailsDataStore;\n  }\n}\nFashionService.ɵfac = function FashionService_Factory(t) {\n  return new (t || FashionService)(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i1.TransferStateHelper), i0.ɵɵinject(i2.HttpClient));\n};\nFashionService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FashionService,\n  factory: FashionService.ɵfac\n});","map":{"version":3,"mappings":"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","names":["PLATFORM_ID","HttpClient","map","isPlatformServer","DataStore","TransferStateHelper","FashionListingModel","FashionDetailsModel","FashionService","constructor","platformId","transferStateHelper","http","getListingDataSource","rawDataSource","get","pipe","data","listing","Object","assign","cachedDataSource","checkDataSourceState","getListingStore","dataSource","listingDataStore","shellModel","load","getDetailsDataSource","details","getDetailsStore","detailsDataStore","factory"],"sourceRoot":"","sources":["/Users/teeicloud/TitanEstates/Titan Estates/src/app/fashion/fashion.service.ts"],"sourcesContent":["import { Inject, Injectable, PLATFORM_ID } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { isPlatformServer } from '@angular/common';\n\nimport { DataStore } from '../shell/data-store';\nimport { TransferStateHelper } from '../utils/transfer-state-helper';\nimport { FashionListingModel } from './listing/fashion-listing.model';\nimport { FashionDetailsModel } from './details/fashion-details.model';\n\n@Injectable()\nexport class FashionService {\n  private listingDataStore: DataStore<FashionListingModel>;\n  private detailsDataStore: DataStore<FashionDetailsModel>;\n\n  constructor(\n    @Inject(PLATFORM_ID) private platformId: object,\n    private transferStateHelper: TransferStateHelper,\n    private http: HttpClient\n  ) { }\n\n  public getListingDataSource(): Observable<FashionListingModel> {\n    const rawDataSource = this.http.get<FashionListingModel>('./assets/sample-data/fashion/listing.json')\n    .pipe(\n      map(\n        (data: FashionListingModel) => {\n          // Note: HttpClient cannot know how to instantiate a class for the returned data\n          // We need to properly cast types from json data\n          const listing = new FashionListingModel();\n\n          // The Object.assign() method copies all enumerable own properties from one or more source objects to a target object.\n          // Note: If you have non-enummerable properties, you can try a spread operator instead. listing = {...data};\n          // (see: https://scotch.io/bar-talk/copying-objects-in-javascript#toc-using-spread-elements-)\n          Object.assign(listing, data);\n\n          return listing;\n        }\n      )\n    );\n\n    // This method tapps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState('fashion-listing-state', rawDataSource);\n\n    return cachedDataSource;\n  }\n\n  public getListingStore(dataSource: Observable<FashionListingModel>): DataStore<FashionListingModel> {\n    // Check if we already loaded this object\n    if (!this.listingDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel: FashionListingModel = new FashionListingModel();\n      this.listingDataStore = new DataStore(shellModel);\n\n      // If running in the server, then don't add shell to the Data Store\n      // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the broswer from the server\n      if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n        // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n        this.listingDataStore.load(dataSource, 0);\n      } else { // On browser transitions\n        // Trigger the loading mechanism (with shell)\n        this.listingDataStore.load(dataSource);\n      }\n    }\n\n    return this.listingDataStore;\n  }\n\n  public getDetailsDataSource(): Observable<FashionDetailsModel> {\n    const rawDataSource = this.http.get<FashionDetailsModel>('./assets/sample-data/fashion/details.json')\n    .pipe(\n      map(\n        (data: FashionDetailsModel) => {\n          // Note: HttpClient cannot know how to instantiate a class for the returned data\n          // We need to properly cast types from json data\n          const details = new FashionDetailsModel();\n\n          // The Object.assign() method copies all enumerable own properties from one or more source objects to a target object.\n          // Note: If you have non-enummerable properties, you can try a spread operator instead. details = {...data};\n          // (see: https://scotch.io/bar-talk/copying-objects-in-javascript#toc-using-spread-elements-)\n          Object.assign(details, data);\n\n          return details;\n        }\n      )\n    );\n\n    // This method tapps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState('fashion-details-state', rawDataSource);\n\n    return cachedDataSource;\n  }\n\n  public getDetailsStore(dataSource: Observable<FashionDetailsModel>): DataStore<FashionDetailsModel> {\n    // Check if we already loaded this object\n    if (!this.detailsDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel: FashionDetailsModel = new FashionDetailsModel();\n      this.detailsDataStore = new DataStore(shellModel);\n\n      // If running in the server, then don't add shell to the Data Store\n      // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the broswer from the server\n      if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n        // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n        this.detailsDataStore.load(dataSource, 0);\n      } else { // On browser transitions\n        // Trigger the loading mechanism (with shell)\n        this.detailsDataStore.load(dataSource);\n      }\n    }\n\n    return this.detailsDataStore;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}