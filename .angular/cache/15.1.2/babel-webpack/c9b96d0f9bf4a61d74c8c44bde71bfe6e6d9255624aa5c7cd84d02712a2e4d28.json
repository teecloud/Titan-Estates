{"ast":null,"code":"import { PLATFORM_ID } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Firestore, collection, collectionData, query, orderBy, startAt, endAt, docData, doc, where, setDoc, updateDoc, deleteDoc, getDoc } from '@angular/fire/firestore';\nimport { of, forkJoin, throwError, combineLatest, from } from 'rxjs';\nimport { map, concatMap, first, filter } from 'rxjs/operators';\nimport * as dayjs from 'dayjs';\nimport { DataStore } from '../../shell/data-store';\nimport { FirebaseListingItemModel } from './../crud/listing/firebase-listing.model';\nimport { FirebaseCombinedUserModel } from './../crud/user/firebase-user.model';\nimport { UserImageModel } from './../crud/user/select-image/user-image.model';\nimport { TransferStateHelper } from '../../utils/transfer-state-helper';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../utils/transfer-state-helper\";\nimport * as i2 from \"@angular/fire/firestore\";\nexport class FirebaseCrudService {\n  constructor(platformId, transferStateHelper, firestore) {\n    this.platformId = platformId;\n    this.transferStateHelper = transferStateHelper;\n    this.firestore = firestore;\n  }\n  // * Firebase User Listing Page\n  getListingDataSource() {\n    const rawDataSource = collectionData(query(collection(this.firestore, 'users')), {\n      idField: 'id'\n    }).pipe(map(users => {\n      return users.map(user => {\n        const age = this.calcUserAge(user.birthdate);\n        return {\n          age,\n          ...user\n        };\n      });\n    }));\n    // This method taps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState('firebase-listing-state', rawDataSource);\n    return cachedDataSource;\n  }\n  getListingStore(dataSource) {\n    // Use cache if available\n    if (!this.listingDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel = [new FirebaseListingItemModel(), new FirebaseListingItemModel(), new FirebaseListingItemModel(), new FirebaseListingItemModel(), new FirebaseListingItemModel(), new FirebaseListingItemModel()];\n      this.listingDataStore = new DataStore(shellModel);\n      // If running in the server, then don't add shell to the Data Store\n      // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the browser from the server\n      if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n        // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n        this.listingDataStore.load(dataSource, 0);\n      } else {\n        // On browser transitions\n        // Trigger the loading mechanism (with shell)\n        this.listingDataStore.load(dataSource);\n      }\n    }\n    return this.listingDataStore;\n  }\n  // * Filter users by age\n  searchUsersByAge(lower, upper) {\n    // ? We save the dateOfBirth in our DB so we need to calc the min and max dates valid for this query\n    const minDate = dayjs(Date.now()).subtract(upper, 'year').unix();\n    const maxDate = dayjs(Date.now()).subtract(lower, 'year').unix();\n    const filteredDataSource = collectionData(query(collection(this.firestore, 'users'), orderBy('birthdate'), startAt(minDate), endAt(maxDate)), {\n      idField: 'id'\n    }).pipe(map(users => {\n      return users.map(user => {\n        const age = this.calcUserAge(user.birthdate);\n        return {\n          age,\n          ...user\n        };\n      });\n    }));\n    return filteredDataSource;\n  }\n  // * Firebase User Details Page\n  // ? Concat the userData with the details of the userSkills (from the skills collection)\n  getCombinedUserDataSource(userId) {\n    const rawDataSource = this.getUser(userId).pipe(\n    // Transformation operator: Map each source value (user) to an Observable (combineDataSources | throwError) which\n    // is merged in the output Observable\n    concatMap(user => {\n      if (user && user.skills) {\n        // Map each skill id and get the skill data as an Observable\n        const userSkillsObservables = user.skills.map(skillId => {\n          // ? first() emits the first value of the source Observable, then completes.\n          return this.getSkill(skillId).pipe(first());\n        });\n        // Combination operator: Take the most recent value from both input sources (of(user) & forkJoin(userSkillsObservables)),\n        // and transform those emitted values into one value ([userDetails, userSkills])\n        return combineLatest([of(user), forkJoin(userSkillsObservables)]).pipe(map(([userDetails, userSkills]) => {\n          // Spread operator (see: https://dev.to/napoleon039/how-to-use-the-spread-and-rest-operator-4jbb)\n          return {\n            ...userDetails,\n            skills: userSkills\n          };\n        }));\n      } else {\n        // Throw error\n        return throwError(() => new Error('User does not have any skills.'));\n      }\n    }));\n    // This method taps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState(`firebase-user-${userId}-state`, rawDataSource);\n    return cachedDataSource;\n  }\n  getCombinedUserStore(dataSource) {\n    // Initialize the model specifying that it is a shell model\n    const shellModel = new FirebaseCombinedUserModel();\n    this.combinedUserDataStore = new DataStore(shellModel);\n    // If running in the server, then don't add shell to the Data Store\n    // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the browser from the server\n    if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n      // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n      this.combinedUserDataStore.load(dataSource, 0);\n    } else {\n      // On browser transitions\n      // Trigger the loading mechanism (with shell)\n      this.combinedUserDataStore.load(dataSource);\n    }\n    return this.combinedUserDataStore;\n  }\n  // eslint-disable-next-line max-len\n  getRelatedUsersDataSource(combinedUserDataSource, userId) {\n    const rawDataSource = combinedUserDataSource.pipe(\n    // Filter user values that are not shells. We need to add this filter if using the combinedUserDataStore timeline\n    filter(user => !user.isShell), concatMap(user => {\n      if (user && user.skills) {\n        // Get all users with at least 1 skill in common\n        const relatedUsersObservable = this.getUsersWithSameSkills(user.id, user.skills);\n        return relatedUsersObservable;\n      } else {\n        // Throw error\n        return throwError(() => new Error('Could not get related user'));\n      }\n    }));\n    // This method taps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState(`firebase-user-${userId}-related-users-state`, rawDataSource);\n    return cachedDataSource;\n  }\n  getRelatedUsersStore(dataSource) {\n    // Initialize the model specifying that it is a shell model\n    const shellModel = [new FirebaseListingItemModel(), new FirebaseListingItemModel(), new FirebaseListingItemModel()];\n    this.relatedUsersDataStore = new DataStore(shellModel);\n    // If running in the server, then don't add shell to the Data Store\n    // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the browser from the server\n    if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n      // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n      this.relatedUsersDataStore.load(dataSource, 0);\n    } else {\n      // On browser transitions\n      // Trigger the loading mechanism (with shell)\n      this.relatedUsersDataStore.load(dataSource);\n    }\n    return this.relatedUsersDataStore;\n  }\n  // * Firebase Create User Modal\n  createUser(user) {\n    // Remove isShell property so it doesn't get stored in Firebase\n    const {\n      isShell,\n      ...userDataToSave\n    } = user;\n    const userDocumentRef = doc(collection(this.firestore, 'users'));\n    return setDoc(userDocumentRef, {\n      ...userDataToSave\n    });\n  }\n  // * Firebase Update User Modal\n  updateUser(user) {\n    // Remove isShell property so it doesn't get stored in Firebase\n    const {\n      isShell,\n      ...userDataToSave\n    } = user;\n    const userDocumentRef = doc(this.firestore, 'users', user.id);\n    return updateDoc(userDocumentRef, {\n      ...userDataToSave\n    });\n  }\n  deleteUser(userId) {\n    const userDocumentRef = doc(this.firestore, 'users', userId);\n    return deleteDoc(userDocumentRef);\n  }\n  // * Firebase Select User Image Modal\n  getAvatarsDataSource() {\n    const avatarsDataSource = collectionData(query(collection(this.firestore, 'avatars')));\n    return avatarsDataSource;\n  }\n  getAvatarsStore(dataSource) {\n    // Use cache if available\n    if (!this.avatarsDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel = [new UserImageModel(), new UserImageModel(), new UserImageModel(), new UserImageModel(), new UserImageModel()];\n      this.avatarsDataStore = new DataStore(shellModel);\n      // Trigger the loading mechanism (with shell) in the dataStore\n      this.avatarsDataStore.load(dataSource);\n    }\n    return this.avatarsDataStore;\n  }\n  // ! FireStore utility methods\n  // * Get list of all available Skills (used in the create and update modals)\n  getSkills() {\n    const skillsDataSource = collectionData(query(collection(this.firestore, 'skills')), {\n      idField: 'id'\n    });\n    return skillsDataSource;\n  }\n  // * Get data of a specific Skill\n  getSkill(skillId) {\n    const skillDataSource = docData(doc(this.firestore, 'skills', skillId), {\n      idField: 'id'\n    });\n    return skillDataSource;\n  }\n  // * Get data of a specific User\n  getUser(userId) {\n    const userDocumentRef = doc(this.firestore, 'users', userId);\n    const userDocumentSnapshotPromise = getDoc(userDocumentRef);\n    const userDataSource = from(userDocumentSnapshotPromise).pipe(map(userSnapshot => {\n      if (userSnapshot.exists()) {\n        const user = userSnapshot.data();\n        const age = this.calcUserAge(user.birthdate);\n        const id = userSnapshot.id;\n        return {\n          id,\n          age,\n          ...user\n        };\n      }\n    }));\n    // ? If you want to listen to document changes use docData() instead\n    // const userDataSource: Observable<FirebaseUserModel> = docData<FirebaseUserModel>(\n    //   doc(this.firestore, 'users', userId) as DocumentReference<FirebaseUserModel>,\n    //   { idField: 'id' }\n    // )\n    // .pipe(\n    //   map((user: FirebaseUserModel) => {\n    //     const age = this.calcUserAge(user.birthdate);\n    //     return { age, ...user } as FirebaseUserModel;\n    //   })\n    // );\n    return userDataSource;\n  }\n  // * Get all users who share at least 1 skill of the user's 'skills' list\n  getUsersWithSameSkills(userId, skills) {\n    // Get the users who have at least 1 skill in common\n    // Because firestore doesn't have a logical 'OR' operator we need to create multiple queries, one for each skill from the 'skills' list\n    const rawAggregatedUsersWithSameSkillsDataSource = skills.map(skill => {\n      const usersWithSameSkillDataSource = collectionData(query(collection(this.firestore, 'users'), where('skills', 'array-contains', skill.id)), {\n        idField: 'id'\n      }).pipe(map(users => {\n        return users.map(user => {\n          const age = this.calcUserAge(user.birthdate);\n          return {\n            age,\n            ...user\n          };\n        });\n      }));\n      return usersWithSameSkillDataSource;\n    });\n    // Combine all these queries\n    const usersWithSameSkillsDataSource = combineLatest(rawAggregatedUsersWithSameSkillsDataSource).pipe(map(relatedUsers => {\n      // Flatten the array of arrays of FirebaseListingItemModel\n      const flattenedRelatedUsers = [].concat(...relatedUsers);\n      // Removes duplicates from the array of FirebaseListingItemModel objects.\n      // Also remove the original user (userId)\n      const filteredRelatedUsers = flattenedRelatedUsers.reduce((accumulatedUsers, user) => {\n        if (accumulatedUsers.findIndex(accumulatedUser => accumulatedUser.id === user.id) < 0 && user.id !== userId) {\n          return [...accumulatedUsers, user];\n        } else {\n          // If the user doesn't pass the test, then don't add it to the filtered users array\n          return accumulatedUsers;\n        }\n      }, []);\n      return filteredRelatedUsers;\n    }));\n    return usersWithSameSkillsDataSource;\n  }\n  calcUserAge(dateOfBirth) {\n    return dayjs(Date.now()).diff(dayjs.unix(dateOfBirth), 'year');\n  }\n}\nFirebaseCrudService.ɵfac = function FirebaseCrudService_Factory(t) {\n  return new (t || FirebaseCrudService)(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i1.TransferStateHelper), i0.ɵɵinject(i2.Firestore));\n};\nFirebaseCrudService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FirebaseCrudService,\n  factory: FirebaseCrudService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["PLATFORM_ID","isPlatformServer","Firestore","collection","collectionData","query","orderBy","startAt","endAt","docData","doc","where","setDoc","updateDoc","deleteDoc","getDoc","of","forkJoin","throwError","combineLatest","from","map","concatMap","first","filter","dayjs","DataStore","FirebaseListingItemModel","FirebaseCombinedUserModel","UserImageModel","TransferStateHelper","FirebaseCrudService","constructor","platformId","transferStateHelper","firestore","getListingDataSource","rawDataSource","idField","pipe","users","user","age","calcUserAge","birthdate","cachedDataSource","checkDataSourceState","getListingStore","dataSource","listingDataStore","shellModel","load","searchUsersByAge","lower","upper","minDate","Date","now","subtract","unix","maxDate","filteredDataSource","getCombinedUserDataSource","userId","getUser","skills","userSkillsObservables","skillId","getSkill","userDetails","userSkills","Error","getCombinedUserStore","combinedUserDataStore","getRelatedUsersDataSource","combinedUserDataSource","isShell","relatedUsersObservable","getUsersWithSameSkills","id","getRelatedUsersStore","relatedUsersDataStore","createUser","userDataToSave","userDocumentRef","updateUser","deleteUser","getAvatarsDataSource","avatarsDataSource","getAvatarsStore","avatarsDataStore","getSkills","skillsDataSource","skillDataSource","userDocumentSnapshotPromise","userDataSource","userSnapshot","exists","data","rawAggregatedUsersWithSameSkillsDataSource","skill","usersWithSameSkillDataSource","usersWithSameSkillsDataSource","relatedUsers","flattenedRelatedUsers","concat","filteredRelatedUsers","reduce","accumulatedUsers","findIndex","accumulatedUser","dateOfBirth","diff","factory","providedIn"],"sourceRoot":"","sources":["/Users/teeicloud/TitanEstates/Titan Estates/src/app/firebase/crud/firebase-crud.service.ts"],"sourcesContent":["import { Inject, Injectable, PLATFORM_ID } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\n\nimport { Firestore, collection, collectionData, query, CollectionReference, orderBy, startAt, endAt, docData, doc, DocumentReference, where, setDoc, updateDoc, deleteDoc, getDoc, DocumentSnapshot } from '@angular/fire/firestore';\n\nimport { Observable, of, forkJoin, throwError, combineLatest, from } from 'rxjs';\nimport { map, concatMap, first, filter } from 'rxjs/operators';\n\nimport * as dayjs from 'dayjs';\n\nimport { DataStore, ShellModel } from '../../shell/data-store';\nimport { FirebaseListingItemModel } from './../crud/listing/firebase-listing.model';\nimport { FirebaseCombinedUserModel, FirebaseSkillModel, FirebaseUserModel } from './../crud/user/firebase-user.model';\nimport { UserImageModel } from './../crud/user/select-image/user-image.model';\nimport { TransferStateHelper } from '../../utils/transfer-state-helper';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FirebaseCrudService {\n  // ? Listing Page\n  private listingDataStore: DataStore<Array<FirebaseListingItemModel>>;\n  // ? User Details Page\n  private combinedUserDataStore: DataStore<FirebaseCombinedUserModel>;\n  private relatedUsersDataStore: DataStore<Array<FirebaseListingItemModel>>;\n  // ? Select User Image Modal\n  private avatarsDataStore: DataStore<Array<UserImageModel>>;\n\n  constructor(\n    @Inject(PLATFORM_ID) private platformId: object,\n    private transferStateHelper: TransferStateHelper,\n    private firestore: Firestore\n  ) {}\n\n  // * Firebase User Listing Page\n  public getListingDataSource(): Observable<Array<FirebaseListingItemModel>> {\n    const rawDataSource: Observable<Array<FirebaseListingItemModel>> = collectionData<FirebaseListingItemModel>(\n      query<FirebaseListingItemModel>(\n        collection(this.firestore, 'users') as CollectionReference<FirebaseListingItemModel>\n      ), { idField: 'id' }\n    )\n    .pipe(\n      map((users: Array<FirebaseListingItemModel>) => {\n        return users.map((user: FirebaseListingItemModel) => {\n          const age = this.calcUserAge(user.birthdate);\n\n          return { age, ...user } as FirebaseListingItemModel;\n        });\n      })\n    );\n\n    // This method taps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState('firebase-listing-state', rawDataSource);\n\n    return cachedDataSource;\n  }\n\n  public getListingStore(dataSource: Observable<Array<FirebaseListingItemModel>>): DataStore<Array<FirebaseListingItemModel>> {\n    // Use cache if available\n    if (!this.listingDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel: Array<FirebaseListingItemModel> = [\n        new FirebaseListingItemModel(),\n        new FirebaseListingItemModel(),\n        new FirebaseListingItemModel(),\n        new FirebaseListingItemModel(),\n        new FirebaseListingItemModel(),\n        new FirebaseListingItemModel()\n      ];\n      this.listingDataStore = new DataStore(shellModel);\n\n      // If running in the server, then don't add shell to the Data Store\n      // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the browser from the server\n      if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n        // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n        this.listingDataStore.load(dataSource, 0);\n      } else { // On browser transitions\n        // Trigger the loading mechanism (with shell)\n        this.listingDataStore.load(dataSource);\n      }\n    }\n\n    return this.listingDataStore;\n  }\n\n  // * Filter users by age\n  public searchUsersByAge(lower: number, upper: number): Observable<Array<FirebaseListingItemModel>> {\n    // ? We save the dateOfBirth in our DB so we need to calc the min and max dates valid for this query\n    const minDate = (dayjs(Date.now()).subtract(upper, 'year')).unix();\n    const maxDate =  (dayjs(Date.now()).subtract(lower, 'year')).unix();\n\n    const filteredDataSource: Observable<Array<FirebaseListingItemModel>> = collectionData<FirebaseListingItemModel>(\n      query<FirebaseListingItemModel>(\n        collection(this.firestore, 'users') as CollectionReference<FirebaseListingItemModel>,\n        orderBy('birthdate'),\n        startAt(minDate),\n        endAt(maxDate)\n      ), { idField: 'id' }\n    )\n    .pipe(\n      map((users: Array<FirebaseListingItemModel>) => {\n        return users.map((user: FirebaseListingItemModel) => {\n          const age = this.calcUserAge(user.birthdate);\n\n          return { age, ...user } as FirebaseListingItemModel;\n        });\n      })\n    );\n\n    return filteredDataSource;\n  }\n\n  // * Firebase User Details Page\n  // ? Concat the userData with the details of the userSkills (from the skills collection)\n  public getCombinedUserDataSource(userId: string): Observable<FirebaseCombinedUserModel> {\n    const rawDataSource = this.getUser(userId)\n    .pipe(\n      // Transformation operator: Map each source value (user) to an Observable (combineDataSources | throwError) which\n      // is merged in the output Observable\n      concatMap(user => {\n        if (user && user.skills) {\n          // Map each skill id and get the skill data as an Observable\n          const userSkillsObservables: Array<Observable<FirebaseSkillModel>> = user.skills.map((skillId: string) => {\n            // ? first() emits the first value of the source Observable, then completes.\n            return this.getSkill(skillId).pipe(first());\n          });\n\n          // Combination operator: Take the most recent value from both input sources (of(user) & forkJoin(userSkillsObservables)),\n          // and transform those emitted values into one value ([userDetails, userSkills])\n          return combineLatest([\n            of(user),\n            forkJoin(userSkillsObservables)\n          ])\n          .pipe(\n            map(([userDetails, userSkills]: [FirebaseUserModel, Array<FirebaseSkillModel>]) => {\n              // Spread operator (see: https://dev.to/napoleon039/how-to-use-the-spread-and-rest-operator-4jbb)\n              return {\n                ...userDetails,\n                skills: userSkills\n              } as FirebaseCombinedUserModel;\n            })\n          );\n        } else {\n          // Throw error\n          return throwError(() => new Error('User does not have any skills.'));\n        }\n      })\n    );\n\n    // This method taps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState(`firebase-user-${userId}-state`, rawDataSource);\n\n    return cachedDataSource;\n  }\n\n  public getCombinedUserStore(dataSource: Observable<FirebaseCombinedUserModel>): DataStore<FirebaseCombinedUserModel> {\n    // Initialize the model specifying that it is a shell model\n    const shellModel: FirebaseCombinedUserModel = new FirebaseCombinedUserModel();\n    this.combinedUserDataStore = new DataStore(shellModel);\n\n    // If running in the server, then don't add shell to the Data Store\n    // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the browser from the server\n    if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n      // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n      this.combinedUserDataStore.load(dataSource, 0);\n    } else { // On browser transitions\n      // Trigger the loading mechanism (with shell)\n      this.combinedUserDataStore.load(dataSource);\n    }\n\n    return this.combinedUserDataStore;\n  }\n\n  // eslint-disable-next-line max-len\n  public getRelatedUsersDataSource(combinedUserDataSource: Observable<FirebaseCombinedUserModel & ShellModel>, userId: string): Observable<Array<FirebaseListingItemModel>>  {\n    const rawDataSource = combinedUserDataSource\n    .pipe(\n      // Filter user values that are not shells. We need to add this filter if using the combinedUserDataStore timeline\n      filter(user => !user.isShell),\n      concatMap(user => {\n        if (user && user.skills) {\n          // Get all users with at least 1 skill in common\n          const relatedUsersObservable: Observable<Array<FirebaseListingItemModel>> =\n          this.getUsersWithSameSkills(user.id, user.skills);\n\n          return relatedUsersObservable;\n        } else {\n          // Throw error\n          return throwError(() => new Error('Could not get related user'));\n        }\n      })\n    );\n\n    // This method taps into the raw data source and stores the resolved data in the TransferState, then when\n    // transitioning from the server rendered view to the browser, checks if we already loaded the data in the server to prevent\n    // duplicate http requests.\n    const cachedDataSource = this.transferStateHelper.checkDataSourceState(`firebase-user-${userId}-related-users-state`, rawDataSource);\n\n    return cachedDataSource;\n  }\n\n  public getRelatedUsersStore(dataSource: Observable<Array<FirebaseListingItemModel>>): DataStore<Array<FirebaseListingItemModel>> {\n    // Initialize the model specifying that it is a shell model\n    const shellModel: Array<FirebaseListingItemModel> = [\n      new FirebaseListingItemModel(),\n      new FirebaseListingItemModel(),\n      new FirebaseListingItemModel()\n    ];\n    this.relatedUsersDataStore = new DataStore(shellModel);\n\n    // If running in the server, then don't add shell to the Data Store\n    // If we already loaded the Data Source in the server, then don't show a shell when transitioning back to the browser from the server\n    if (isPlatformServer(this.platformId) || dataSource['ssr_state']) {\n      // Trigger loading mechanism with 0 delay (this will prevent the shell to be shown)\n      this.relatedUsersDataStore.load(dataSource, 0);\n    } else { // On browser transitions\n      // Trigger the loading mechanism (with shell)\n      this.relatedUsersDataStore.load(dataSource);\n    }\n\n    return this.relatedUsersDataStore;\n  }\n\n  // * Firebase Create User Modal\n  public createUser(user: FirebaseUserModel): Promise<void> {\n    // Remove isShell property so it doesn't get stored in Firebase\n    const { isShell, ...userDataToSave } = user;\n    const userDocumentRef = doc(collection(this.firestore, 'users'));\n\n    return setDoc(userDocumentRef, {...userDataToSave});\n  }\n\n  // * Firebase Update User Modal\n  public updateUser(user: FirebaseUserModel): Promise<void> {\n    // Remove isShell property so it doesn't get stored in Firebase\n    const { isShell, ...userDataToSave } = user;\n    const userDocumentRef = doc(this.firestore, 'users', user.id);\n\n    return updateDoc(userDocumentRef, {...userDataToSave});\n  }\n\n  public deleteUser(userId: string): Promise<void> {\n    const userDocumentRef = doc(this.firestore, 'users', userId);\n\n    return deleteDoc(userDocumentRef);\n  }\n\n  // * Firebase Select User Image Modal\n  public getAvatarsDataSource(): Observable<Array<UserImageModel>> {\n    const avatarsDataSource: Observable<Array<UserImageModel>> = collectionData<UserImageModel>(\n      query<UserImageModel>(\n        collection(this.firestore, 'avatars') as CollectionReference<UserImageModel>\n      )\n    );\n\n    return avatarsDataSource;\n  }\n\n  public getAvatarsStore(dataSource: Observable<Array<UserImageModel>>): DataStore<Array<UserImageModel>> {\n    // Use cache if available\n    if (!this.avatarsDataStore) {\n      // Initialize the model specifying that it is a shell model\n      const shellModel: Array<UserImageModel> = [\n        new UserImageModel(),\n        new UserImageModel(),\n        new UserImageModel(),\n        new UserImageModel(),\n        new UserImageModel()\n      ];\n\n      this.avatarsDataStore = new DataStore(shellModel);\n      // Trigger the loading mechanism (with shell) in the dataStore\n      this.avatarsDataStore.load(dataSource);\n    }\n\n    return this.avatarsDataStore;\n  }\n\n\n  // ! FireStore utility methods\n\n\n  // * Get list of all available Skills (used in the create and update modals)\n  public getSkills(): Observable<Array<FirebaseSkillModel>> {\n    const skillsDataSource: Observable<Array<FirebaseSkillModel>> = collectionData<FirebaseSkillModel>(\n      query<FirebaseSkillModel>(\n        collection(this.firestore, 'skills') as CollectionReference<FirebaseSkillModel>\n      ),\n      { idField: 'id' }\n    );\n\n    return skillsDataSource;\n  }\n\n  // * Get data of a specific Skill\n  private getSkill(skillId: string): Observable<FirebaseSkillModel> {\n    const skillDataSource: Observable<FirebaseSkillModel> = docData<FirebaseSkillModel>(\n      doc(this.firestore, 'skills', skillId) as DocumentReference<FirebaseSkillModel>,\n      { idField: 'id' }\n    );\n\n    return skillDataSource;\n  }\n\n  // * Get data of a specific User\n  private getUser(userId: string): Observable<FirebaseUserModel> {\n    const userDocumentRef = doc(this.firestore, 'users', userId) as DocumentReference<FirebaseUserModel>;\n    const userDocumentSnapshotPromise = getDoc(userDocumentRef);\n\n    const userDataSource: Observable<FirebaseUserModel> = from(userDocumentSnapshotPromise)\n    .pipe(\n      map((userSnapshot: DocumentSnapshot<FirebaseUserModel>) => {\n        if (userSnapshot.exists()) {\n          const user: FirebaseUserModel = userSnapshot.data();\n          const age = this.calcUserAge(user.birthdate);\n          const id = userSnapshot.id;\n\n          return { id, age, ...user } as FirebaseUserModel;\n        }\n      })\n    );\n\n    // ? If you want to listen to document changes use docData() instead\n    // const userDataSource: Observable<FirebaseUserModel> = docData<FirebaseUserModel>(\n    //   doc(this.firestore, 'users', userId) as DocumentReference<FirebaseUserModel>,\n    //   { idField: 'id' }\n    // )\n    // .pipe(\n    //   map((user: FirebaseUserModel) => {\n    //     const age = this.calcUserAge(user.birthdate);\n    //     return { age, ...user } as FirebaseUserModel;\n    //   })\n    // );\n\n    return userDataSource;\n  }\n\n  // * Get all users who share at least 1 skill of the user's 'skills' list\n  private getUsersWithSameSkills(userId: string, skills: Array<FirebaseSkillModel>): Observable<Array<FirebaseListingItemModel>> {\n    // Get the users who have at least 1 skill in common\n    // Because firestore doesn't have a logical 'OR' operator we need to create multiple queries, one for each skill from the 'skills' list\n    const rawAggregatedUsersWithSameSkillsDataSource: Array<Observable<Array<FirebaseListingItemModel>>> = skills.map(skill => {\n      const usersWithSameSkillDataSource: Observable<Array<FirebaseListingItemModel>> = collectionData<FirebaseListingItemModel>(\n        query<FirebaseListingItemModel>(\n          collection(this.firestore, 'users') as CollectionReference<FirebaseListingItemModel>,\n          where('skills', 'array-contains', skill.id)\n        ),\n        { idField: 'id' }\n      )\n      .pipe(\n        map((users: Array<FirebaseListingItemModel>) => {\n          return users.map((user: FirebaseListingItemModel) => {\n            const age = this.calcUserAge(user.birthdate);\n  \n            return { age, ...user } as FirebaseListingItemModel;\n          });\n        })\n      );\n\n      return usersWithSameSkillDataSource;\n    });\n\n    // Combine all these queries\n    const usersWithSameSkillsDataSource: Observable<Array<FirebaseListingItemModel>> = combineLatest(rawAggregatedUsersWithSameSkillsDataSource)\n    .pipe(\n      map((relatedUsers: FirebaseListingItemModel[][]) => {\n        // Flatten the array of arrays of FirebaseListingItemModel\n        const flattenedRelatedUsers = ([] as FirebaseListingItemModel[]).concat(...relatedUsers);\n\n        // Removes duplicates from the array of FirebaseListingItemModel objects.\n        // Also remove the original user (userId)\n        const filteredRelatedUsers = flattenedRelatedUsers\n        .reduce((accumulatedUsers, user) => {\n          if ((accumulatedUsers.findIndex(accumulatedUser => accumulatedUser.id === user.id) < 0) && (user.id !== userId)) {\n            return [...accumulatedUsers, user];\n          } else {\n            // If the user doesn't pass the test, then don't add it to the filtered users array\n            return accumulatedUsers;\n          }\n        }, ([] as FirebaseListingItemModel[]));\n\n        return filteredRelatedUsers;\n      })\n    );\n\n    return usersWithSameSkillsDataSource;\n  }\n\n  private calcUserAge(dateOfBirth: number): number {\n    return dayjs(Date.now()).diff(dayjs.unix(dateOfBirth), 'year');\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}