{"ast":null,"code":"import _asyncToGenerator from \"/Users/teeicloud/TitanEstates/Titan Estates/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { NgZone, PLATFORM_ID } from '@angular/core';\nimport { isPlatformBrowser, Location } from '@angular/common';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { LoadingController, Platform } from '@ionic/angular';\nimport { Subject, of } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport { FacebookAuthProvider, GoogleAuthProvider, TwitterAuthProvider, OAuthProvider, createUserWithEmailAndPassword, getAuth, getRedirectResult, signInWithCredential, signInWithEmailAndPassword, signInWithPopup, signInWithRedirect, signOut } from '@angular/fire/auth';\nimport { FirebaseAuthentication } from '@capacitor-firebase/authentication';\nimport { DataStore } from '../../shell/data-store';\nimport { FirebaseProfileModel } from './profile/firebase-profile.model';\nimport { SignInProvider } from './firebase-auth-definitions';\nimport { FirebaseAuthHelper } from './firebase-auth.helper';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"@ionic/angular\";\nimport * as i3 from \"./firebase-auth.helper\";\nimport * as i4 from \"@angular/common\";\nexport class FirebaseAuthService {\n  constructor(router, route, platform, ngZone, firebaseAuthHelper, loadingController, location, platformId) {\n    this.router = router;\n    this.route = route;\n    this.platform = platform;\n    this.ngZone = ngZone;\n    this.firebaseAuthHelper = firebaseAuthHelper;\n    this.loadingController = loadingController;\n    this.location = location;\n    this.platformId = platformId;\n    this.redirectResultSubject = new Subject();\n    this.authStateSubject = new Subject();\n    if (isPlatformBrowser(this.platformId)) {\n      FirebaseAuthentication.removeAllListeners().then(() => {\n        FirebaseAuthentication.addListener('authStateChange', change => {\n          this.ngZone.run(() => {\n            this.authStateSubject.next(change);\n          });\n          if (change?.user) {\n            // ? User is signed in.\n            this.currentUser = change.user;\n          } else {\n            // ? No user is signed in.\n            this.currentUser = null;\n          }\n        });\n      });\n      // ? We should only listen for firebase auth redirect results when we have the flag 'auth-redirect' in the query params\n      this.route.queryParams.subscribe(params => {\n        const authProvider = params['auth-redirect'];\n        if (authProvider) {\n          // ? Show a loader while we receive the getRedirectResult notification\n          this.presentLoading(authProvider);\n          // ? When using signInWithRedirect, this listens for the redirect results\n          const auth = getAuth();\n          getRedirectResult(auth).then(result => {\n            // ? result.credential.accessToken gives you the Provider Access Token. You can use it to access the Provider API.\n            // const credential = FacebookAuthProvider.credentialFromResult(result);\n            // const token = credential.accessToken;\n            let credential;\n            if (result && result !== null) {\n              switch (result.providerId) {\n                case SignInProvider.apple:\n                  credential = OAuthProvider.credentialFromResult(result);\n                  break;\n                case SignInProvider.facebook:\n                  credential = FacebookAuthProvider.credentialFromResult(result);\n                  break;\n                case SignInProvider.google:\n                  credential = GoogleAuthProvider.credentialFromResult(result);\n                  break;\n                case SignInProvider.twitter:\n                  credential = TwitterAuthProvider.credentialFromResult(result);\n                  break;\n              }\n              const signInResult = firebaseAuthHelper.createSignInResult(result, credential);\n              this.dismissLoading();\n              this.redirectResultSubject.next(signInResult);\n            } else {\n              throw new Error('Could not get user from redirect result');\n            }\n          }, reason => {\n            console.log('Promise rejected', reason);\n            // ? Clear redirection loading\n            this.clearAuthWithProvidersRedirection();\n          }).catch(error => {\n            // ? Clear redirection loading\n            this.clearAuthWithProvidersRedirection();\n            // ? Handle Errors here\n            // const errorCode = error.code;\n            // const errorMessage = error.message;\n            // ? The email of the user's account used.\n            // const email = error.email;\n            // ?AuthCredential type that was used.\n            // const credential = FacebookAuthProvider.credentialFromError(error);\n            let errorResult = {\n              error: 'undefined'\n            };\n            if (error && (error.code || error.message)) {\n              errorResult = {\n                error: error.code ? error.code : error.message\n              };\n            }\n            this.redirectResultSubject.next(errorResult);\n          });\n        }\n      });\n    }\n  }\n  ngOnDestroy() {\n    this.dismissLoading();\n  }\n  prepareForAuthWithProvidersRedirection(authProviderId) {\n    // ? Before invoking auth provider redirect flow, add a flag to the path.\n    // ? The presence of the flag in the path indicates we should wait for the auth redirect to complete\n    this.location.replaceState(this.location.path(), 'auth-redirect=' + authProviderId, this.location.getState());\n  }\n  clearAuthWithProvidersRedirection() {\n    // ? Remove auth-redirect param from url\n    this.location.replaceState(this.router.url.split('?')[0], '');\n    this.dismissLoading();\n  }\n  presentLoading(authProviderId) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const authProviderCapitalized = authProviderId[0].toUpperCase() + authProviderId.slice(1);\n      _this.loadingController.create({\n        message: authProviderId ? 'Signing in with ' + authProviderCapitalized : 'Signing in ...',\n        duration: 4000\n      }).then(loader => {\n        _this.authLoader = loader;\n        _this.authLoader.present();\n      });\n    })();\n  }\n  dismissLoading() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.authLoader) {\n        yield _this2.authLoader.dismiss();\n      }\n    })();\n  }\n  signOut() {\n    return _asyncToGenerator(function* () {\n      const signOutPromise = new Promise((resolve, reject) => {\n        // * 1. Sign out on the native layer\n        FirebaseAuthentication.signOut().then(nativeResult => {\n          // * 2. Sign out on the web layer\n          const auth = getAuth();\n          signOut(auth).then(webResult => {\n            // ? Sign-out successful\n            resolve('Successfully sign out from native and web');\n          }).catch(webError => {\n            // ? An error happened\n            reject(`Web auth sign out error: ${webError}`);\n          });\n        }).catch(nativeError => {\n          reject(`Native auth sign out error: ${nativeError}`);\n        });\n      });\n      return signOutPromise;\n    })();\n  }\n  socialSignIn(provider, authOptions) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.presentLoading(provider.providerId);\n      let authResult = null;\n      if (_this3.platform.is('capacitor')) {\n        authResult = yield _this3.nativeAuth(provider, authOptions);\n      } else {\n        authResult = yield _this3.webAuth(provider, authOptions);\n      }\n      _this3.dismissLoading();\n      if (authResult !== null) {\n        return authResult;\n      } else {\n        return Promise.reject('Could not perform social sign in, authResult is null');\n      }\n    })();\n  }\n  webAuth(provider, authOptions) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const auth = getAuth();\n      let webAuthUserCredential = null;\n      _this4.firebaseAuthHelper.applySignInOptions(authOptions || {}, provider);\n      if (_this4.platform.is('desktop')) {\n        webAuthUserCredential = yield signInWithPopup(auth, provider);\n      } else {\n        // ? Web but not desktop, for example mobile PWA\n        _this4.prepareForAuthWithProvidersRedirection(provider.providerId);\n        return signInWithRedirect(auth, provider);\n        // ? If you prefer to use signInWithPopup in every scenario, just un-comment this line\n        // webAuthUserCredential = await signInWithPopup(auth, provider);\n      }\n\n      if (webAuthUserCredential && webAuthUserCredential !== null) {\n        let webCredential = null;\n        switch (provider.providerId) {\n          case SignInProvider.apple:\n            webCredential = OAuthProvider.credentialFromResult(webAuthUserCredential);\n            break;\n          case SignInProvider.facebook:\n            webCredential = FacebookAuthProvider.credentialFromResult(webAuthUserCredential);\n            break;\n          case SignInProvider.google:\n            webCredential = GoogleAuthProvider.credentialFromResult(webAuthUserCredential);\n            break;\n          case SignInProvider.twitter:\n            webCredential = TwitterAuthProvider.credentialFromResult(webAuthUserCredential);\n            break;\n        }\n        return _this4.firebaseAuthHelper.createSignInResult(webAuthUserCredential, webCredential);\n      } else {\n        return Promise.reject('null webAuthUserCredential');\n      }\n    })();\n  }\n  nativeAuth(provider, authOptions) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      let nativeAuthResult = null;\n      // * 1. Sign in on the native layer\n      switch (provider.providerId) {\n        case SignInProvider.apple:\n          nativeAuthResult = yield FirebaseAuthentication.signInWithApple(authOptions);\n          break;\n        case SignInProvider.facebook:\n          nativeAuthResult = yield FirebaseAuthentication.signInWithFacebook(authOptions);\n          break;\n        case SignInProvider.google:\n          nativeAuthResult = yield FirebaseAuthentication.signInWithGoogle(authOptions);\n          break;\n        case SignInProvider.twitter:\n          nativeAuthResult = yield FirebaseAuthentication.signInWithTwitter(authOptions);\n          break;\n      }\n      // ? Once we have the user authenticated on the native layer, authenticate it in the web layer\n      if (nativeAuthResult && nativeAuthResult !== null) {\n        const auth = getAuth();\n        let nativeCredential = null;\n        switch (provider.providerId) {\n          case SignInProvider.apple:\n            const provider = new OAuthProvider(SignInProvider.apple);\n            nativeCredential = provider.credential({\n              idToken: nativeAuthResult.credential?.idToken,\n              rawNonce: nativeAuthResult.credential?.nonce\n            });\n            break;\n          case SignInProvider.facebook:\n            nativeCredential = FacebookAuthProvider.credential(nativeAuthResult.credential?.accessToken);\n            break;\n          case SignInProvider.google:\n            nativeCredential = GoogleAuthProvider.credential(nativeAuthResult.credential?.idToken, nativeAuthResult.credential?.accessToken);\n            break;\n          case SignInProvider.twitter:\n            try {\n              nativeCredential = TwitterAuthProvider.credential(nativeAuthResult.credential?.accessToken, nativeAuthResult.credential?.secret);\n              break;\n            } catch (error) {\n              console.error(error);\n            }\n        }\n        // * 2. Sign in on the web layer using the access token we got from the native sign in\n        const webAuthResult = yield signInWithCredential(auth, nativeCredential);\n        return _this5.firebaseAuthHelper.createSignInResult(webAuthResult, nativeCredential);\n      } else {\n        return Promise.reject('null nativeAuthResult');\n      }\n    })();\n  }\n  signInWithFacebook() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const provider = new FacebookAuthProvider();\n      const authOptions = {\n        scopes: ['email', 'public_profile']\n      };\n      // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n      return _this6.socialSignIn(provider, authOptions);\n    })();\n  }\n  signInWithGoogle() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const provider = new GoogleAuthProvider();\n      const authOptions = {\n        scopes: ['email', 'profile']\n      };\n      // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n      return _this7.socialSignIn(provider, authOptions);\n    })();\n  }\n  signInWithTwitter() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const provider = new TwitterAuthProvider();\n      const authOptions = {\n        scopes: ['email', 'name']\n      };\n      // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n      return _this8.socialSignIn(provider, authOptions);\n    })();\n  }\n  signInWithApple() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const provider = new OAuthProvider('apple.com');\n      const authOptions = {\n        scopes: ['email', 'name']\n      };\n      // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n      return _this9.socialSignIn(provider, authOptions);\n    })();\n  }\n  signInWithEmail(email, password) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      // ? Show a loader while we attempt to perform the login\n      _this10.presentLoading('email');\n      const auth = getAuth();\n      const credential = yield signInWithEmailAndPassword(auth, email, password);\n      _this10.dismissLoading();\n      return _this10.firebaseAuthHelper.createSignInResult(credential, null);\n    })();\n  }\n  signUpWithEmail(email, password) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      // ? Show a loader while we attempt to perform the signup\n      _this11.presentLoading('email');\n      const auth = getAuth();\n      const credential = yield createUserWithEmailAndPassword(auth, email, password);\n      _this11.dismissLoading();\n      return _this11.firebaseAuthHelper.createSignInResult(credential, null);\n    })();\n  }\n  get redirectResult$() {\n    return this.redirectResultSubject.asObservable();\n  }\n  get authState$() {\n    return this.authStateSubject.asObservable();\n  }\n  getProfileDataSource() {\n    const auth = getAuth();\n    return of(auth.currentUser).pipe(filter(user => user != null), map(user => {\n      const userResult = this.firebaseAuthHelper.createUserResult(user);\n      return this.setUserModelForProfile(userResult);\n    }));\n  }\n  setUserModelForProfile(userResult) {\n    const userModel = new FirebaseProfileModel();\n    if (userResult) {\n      userModel.image = this.getPhotoURL(userResult.providerId, userResult.photoUrl);\n      userModel.name = userResult.displayName || 'What\\'s your name?';\n      userModel.role = 'How would you describe yourself?';\n      userModel.description = 'Anything else you would like to share with the world?';\n      userModel.phoneNumber = userResult.phoneNumber || 'Is there a number where I can reach you?';\n      userModel.email = userResult.email || 'Where can I send you emails?';\n      userModel.provider = userResult.providerId !== 'password' ? userResult.providerId : 'Credentials';\n    }\n    return userModel;\n  }\n  getProfileStore(dataSource) {\n    // ? Initialize the model specifying that it is a shell model\n    const shellModel = new FirebaseProfileModel();\n    this.profileDataStore = new DataStore(shellModel);\n    // ? Trigger the loading mechanism (with shell) in the dataStore\n    this.profileDataStore.load(dataSource);\n    return this.profileDataStore;\n  }\n  getPhotoURL(signInProviderId, photoURL) {\n    // ? Default imgs are too small and our app needs a bigger image\n    switch (signInProviderId) {\n      case SignInProvider.facebook:\n        return photoURL + '?height=400';\n      case SignInProvider.twitter:\n        return photoURL.replace('_normal', '_400x400');\n      case SignInProvider.google:\n        return photoURL.split('=')[0];\n      case 'password':\n        return 'https://s3-us-west-2.amazonaws.com/ionicthemes/otros/avatar-placeholder.png';\n      default:\n        return photoURL;\n    }\n  }\n}\nFirebaseAuthService.ɵfac = function FirebaseAuthService_Factory(t) {\n  return new (t || FirebaseAuthService)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i1.ActivatedRoute), i0.ɵɵinject(i2.Platform), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i3.FirebaseAuthHelper), i0.ɵɵinject(i2.LoadingController), i0.ɵɵinject(i4.Location), i0.ɵɵinject(PLATFORM_ID));\n};\nFirebaseAuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FirebaseAuthService,\n  factory: FirebaseAuthService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["NgZone","PLATFORM_ID","isPlatformBrowser","Location","ActivatedRoute","Router","LoadingController","Platform","Subject","of","filter","map","FacebookAuthProvider","GoogleAuthProvider","TwitterAuthProvider","OAuthProvider","createUserWithEmailAndPassword","getAuth","getRedirectResult","signInWithCredential","signInWithEmailAndPassword","signInWithPopup","signInWithRedirect","signOut","FirebaseAuthentication","DataStore","FirebaseProfileModel","SignInProvider","FirebaseAuthHelper","FirebaseAuthService","constructor","router","route","platform","ngZone","firebaseAuthHelper","loadingController","location","platformId","removeAllListeners","then","addListener","change","run","authStateSubject","next","user","currentUser","queryParams","subscribe","params","authProvider","presentLoading","auth","result","credential","providerId","apple","credentialFromResult","facebook","google","twitter","signInResult","createSignInResult","dismissLoading","redirectResultSubject","Error","reason","console","log","clearAuthWithProvidersRedirection","catch","error","errorResult","code","message","ngOnDestroy","prepareForAuthWithProvidersRedirection","authProviderId","replaceState","path","getState","url","split","authProviderCapitalized","toUpperCase","slice","create","duration","loader","authLoader","present","dismiss","signOutPromise","Promise","resolve","reject","nativeResult","webResult","webError","nativeError","socialSignIn","provider","authOptions","authResult","is","nativeAuth","webAuth","webAuthUserCredential","applySignInOptions","webCredential","nativeAuthResult","signInWithApple","signInWithFacebook","signInWithGoogle","signInWithTwitter","nativeCredential","idToken","rawNonce","nonce","accessToken","secret","webAuthResult","scopes","signInWithEmail","email","password","signUpWithEmail","redirectResult$","asObservable","authState$","getProfileDataSource","pipe","userResult","createUserResult","setUserModelForProfile","userModel","image","getPhotoURL","photoUrl","name","displayName","role","description","phoneNumber","getProfileStore","dataSource","shellModel","profileDataStore","load","signInProviderId","photoURL","replace","factory","providedIn"],"sourceRoot":"","sources":["/Users/teeicloud/TitanEstates/Titan Estates/src/app/firebase/auth/firebase-auth.service.ts"],"sourcesContent":["import { Inject, Injectable, NgZone, OnDestroy, PLATFORM_ID } from '@angular/core';\nimport { isPlatformBrowser, Location } from '@angular/common';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { LoadingController, Platform } from '@ionic/angular';\n\nimport { Observable, Subject, of } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\n\nimport { AuthProvider, FacebookAuthProvider, GoogleAuthProvider, TwitterAuthProvider, OAuthProvider, OAuthCredential, UserCredential, createUserWithEmailAndPassword, getAuth, getRedirectResult, signInWithCredential, signInWithEmailAndPassword, signInWithPopup, signInWithRedirect, signOut } from '@angular/fire/auth';\n\nimport type {\n  User as FirebaseUser\n} from '@angular/fire/auth';\n\nimport { AuthStateChange, FirebaseAuthentication, SignInResult, SignInWithOAuthOptions, User } from '@capacitor-firebase/authentication';\n\nimport { DataStore } from '../../shell/data-store';\nimport { FirebaseProfileModel } from './profile/firebase-profile.model';\nimport { SignInProvider } from './firebase-auth-definitions';\nimport { FirebaseAuthHelper } from './firebase-auth.helper';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FirebaseAuthService implements OnDestroy {\n  currentUser: User;\n  authLoader: HTMLIonLoadingElement;\n  profileDataStore: DataStore<FirebaseProfileModel>;\n  redirectResultSubject: Subject<any> = new Subject<any>();\n  authStateSubject: Subject<AuthStateChange> = new Subject<AuthStateChange>();\n\n  constructor(\n    public router: Router,\n    public route: ActivatedRoute,\n    public platform: Platform,\n    private ngZone: NgZone,\n    private firebaseAuthHelper: FirebaseAuthHelper,\n    public loadingController: LoadingController,\n    public location: Location,\n    @Inject(PLATFORM_ID) private platformId: object\n  ) {\n    if (isPlatformBrowser(this.platformId)) {\n      FirebaseAuthentication.removeAllListeners().then(() => {\n        FirebaseAuthentication.addListener('authStateChange', (change: AuthStateChange) => {\n          this.ngZone.run(() => {\n            this.authStateSubject.next(change);\n          });\n\n          if (change?.user) {\n            // ? User is signed in.\n            this.currentUser = change.user;\n          } else {\n            // ? No user is signed in.\n            this.currentUser = null;\n          }\n        });\n      });\n\n      // ? We should only listen for firebase auth redirect results when we have the flag 'auth-redirect' in the query params\n      this.route.queryParams.subscribe(params => {\n        const authProvider = params['auth-redirect'];\n\n        if (authProvider) {\n          // ? Show a loader while we receive the getRedirectResult notification\n          this.presentLoading(authProvider);\n\n          // ? When using signInWithRedirect, this listens for the redirect results\n          const auth = getAuth();\n          getRedirectResult(auth)\n          .then((result: UserCredential) => {\n            // ? result.credential.accessToken gives you the Provider Access Token. You can use it to access the Provider API.\n            // const credential = FacebookAuthProvider.credentialFromResult(result);\n            // const token = credential.accessToken;\n\n            let credential: any;\n\n            if (result && result !== null) {\n              switch (result.providerId) {\n                case SignInProvider.apple:\n                  credential = OAuthProvider.credentialFromResult(result);\n                  break;\n                case SignInProvider.facebook:\n                  credential = FacebookAuthProvider.credentialFromResult(result);\n                  break;\n                case SignInProvider.google:\n                  credential = GoogleAuthProvider.credentialFromResult(result);\n                  break;\n                case SignInProvider.twitter:\n                  credential = TwitterAuthProvider.credentialFromResult(result);\n                  break;\n              }\n\n              const signInResult = firebaseAuthHelper.createSignInResult(result, credential);\n\n              this.dismissLoading();\n\n              this.redirectResultSubject.next(signInResult);\n            } else {\n              throw new Error('Could not get user from redirect result');\n            }\n          }, (reason) => {\n            console.log('Promise rejected', reason);\n\n            // ? Clear redirection loading\n            this.clearAuthWithProvidersRedirection();\n          }).catch((error) => {\n            // ? Clear redirection loading\n            this.clearAuthWithProvidersRedirection();\n\n            // ? Handle Errors here\n            // const errorCode = error.code;\n            // const errorMessage = error.message;\n            // ? The email of the user's account used.\n            // const email = error.email;\n            // ?AuthCredential type that was used.\n            // const credential = FacebookAuthProvider.credentialFromError(error);\n\n            let errorResult = {error: 'undefined'};\n\n            if (error && (error.code || error.message)) {\n              errorResult = {error: (error.code ? error.code : error.message)};\n            }\n\n            this.redirectResultSubject.next(errorResult);\n          });\n        }\n      });\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.dismissLoading();\n  }\n\n  private prepareForAuthWithProvidersRedirection(authProviderId: string): void {\n    // ? Before invoking auth provider redirect flow, add a flag to the path.\n    // ? The presence of the flag in the path indicates we should wait for the auth redirect to complete\n    this.location.replaceState(this.location.path(), 'auth-redirect=' + authProviderId, this.location.getState());\n  }\n\n  private clearAuthWithProvidersRedirection(): void {\n    // ? Remove auth-redirect param from url\n    this.location.replaceState(this.router.url.split('?')[0], '');\n    this.dismissLoading();\n  }\n\n  private async presentLoading(authProviderId?: string): Promise<void> {\n    const authProviderCapitalized = authProviderId[0].toUpperCase() + authProviderId.slice(1);\n\n    this.loadingController.create({\n      message: authProviderId ? 'Signing in with ' + authProviderCapitalized : 'Signing in ...',\n      duration: 4000\n    }).then((loader) => {\n      this.authLoader = loader;\n      this.authLoader.present();\n    });\n  }\n\n  private async dismissLoading(): Promise<void> {\n    if (this.authLoader) {\n      await this.authLoader.dismiss();\n    }\n  }\n\n  public async signOut(): Promise<string> {\n    const signOutPromise = new Promise<string>((resolve, reject) => {\n      // * 1. Sign out on the native layer\n      FirebaseAuthentication.signOut()\n      .then((nativeResult) => {\n        // * 2. Sign out on the web layer\n        const auth = getAuth();\n        signOut(auth)\n        .then((webResult) => {\n          // ? Sign-out successful\n          resolve('Successfully sign out from native and web');\n        }).catch((webError) => {\n          // ? An error happened\n          reject(`Web auth sign out error: ${webError}`);\n        });\n      })\n      .catch((nativeError) => {\n        reject(`Native auth sign out error: ${nativeError}`);\n      });\n    });\n\n    return signOutPromise;\n  }\n\n  private async socialSignIn(provider: (OAuthProvider | GoogleAuthProvider | FacebookAuthProvider | TwitterAuthProvider), authOptions?: SignInWithOAuthOptions): Promise<SignInResult> {\n    this.presentLoading(provider.providerId);\n\n    let authResult: SignInResult = null;\n\n    if (this.platform.is('capacitor')) {\n      authResult = await this.nativeAuth(provider, authOptions);\n    } else {\n      authResult = await this.webAuth(provider, authOptions);\n    }\n\n    this.dismissLoading();\n\n    if (authResult !== null) {\n      return authResult;\n    } else {\n      return Promise.reject('Could not perform social sign in, authResult is null');\n    }\n  }\n\n  private async webAuth(provider: (OAuthProvider | GoogleAuthProvider | FacebookAuthProvider | TwitterAuthProvider), authOptions?: SignInWithOAuthOptions): Promise<SignInResult> {\n    const auth = getAuth();\n    let webAuthUserCredential: UserCredential = null;\n\n    this.firebaseAuthHelper.applySignInOptions(authOptions || {}, provider);\n\n    if (this.platform.is('desktop')) {\n      webAuthUserCredential = await signInWithPopup(auth, provider);\n    } else {\n      // ? Web but not desktop, for example mobile PWA\n      this.prepareForAuthWithProvidersRedirection(provider.providerId);\n      return signInWithRedirect(auth, provider);\n\n      // ? If you prefer to use signInWithPopup in every scenario, just un-comment this line\n      // webAuthUserCredential = await signInWithPopup(auth, provider);\n    }\n\n    if (webAuthUserCredential && webAuthUserCredential !== null) {\n      let webCredential: OAuthCredential = null;\n\n      switch (provider.providerId) {\n        case SignInProvider.apple:\n          webCredential = OAuthProvider.credentialFromResult(webAuthUserCredential);\n          break;\n        case SignInProvider.facebook:\n          webCredential = FacebookAuthProvider.credentialFromResult(webAuthUserCredential);\n          break;\n        case SignInProvider.google:\n          webCredential = GoogleAuthProvider.credentialFromResult(webAuthUserCredential);\n          break;\n        case SignInProvider.twitter:\n          webCredential = TwitterAuthProvider.credentialFromResult(webAuthUserCredential);\n          break;\n      }\n\n      return this.firebaseAuthHelper.createSignInResult(webAuthUserCredential, webCredential);\n    } else {\n      return Promise.reject('null webAuthUserCredential');\n    }\n  }\n\n  private async nativeAuth(provider: AuthProvider, authOptions?: SignInWithOAuthOptions): Promise<SignInResult> {\n    let nativeAuthResult: SignInResult = null;\n\n    // * 1. Sign in on the native layer\n    switch (provider.providerId) {\n      case SignInProvider.apple:\n        nativeAuthResult = await FirebaseAuthentication.signInWithApple(authOptions);\n        break;\n      case SignInProvider.facebook:\n        nativeAuthResult = await FirebaseAuthentication.signInWithFacebook(authOptions);\n        break;\n      case SignInProvider.google:\n        nativeAuthResult = await FirebaseAuthentication.signInWithGoogle(authOptions);\n        break;\n      case SignInProvider.twitter:\n        nativeAuthResult = await FirebaseAuthentication.signInWithTwitter(authOptions);\n        break;\n    }\n\n    // ? Once we have the user authenticated on the native layer, authenticate it in the web layer\n    if (nativeAuthResult && nativeAuthResult !== null) {\n      const auth = getAuth();\n      let nativeCredential: OAuthCredential = null;\n\n      switch (provider.providerId) {\n        case SignInProvider.apple:\n          const provider = new OAuthProvider(SignInProvider.apple);\n          nativeCredential = provider.credential({\n            idToken: nativeAuthResult.credential?.idToken,\n            rawNonce: nativeAuthResult.credential?.nonce\n          });\n          break;\n        case SignInProvider.facebook:\n          nativeCredential = FacebookAuthProvider.credential(\n            nativeAuthResult.credential?.accessToken\n          );\n          break;\n        case SignInProvider.google:\n          nativeCredential = GoogleAuthProvider.credential(\n            nativeAuthResult.credential?.idToken,\n            nativeAuthResult.credential?.accessToken\n          );\n          break;\n        case SignInProvider.twitter:\n          try {\n            nativeCredential = TwitterAuthProvider.credential(\n              nativeAuthResult.credential?.accessToken,\n              nativeAuthResult.credential?.secret\n            );\n            break;\n          } catch (error) {\n            console.error(error);\n          }\n      }\n\n      // * 2. Sign in on the web layer using the access token we got from the native sign in\n      const webAuthResult = await signInWithCredential(auth, nativeCredential);\n\n      return this.firebaseAuthHelper.createSignInResult(webAuthResult, nativeCredential);\n    } else {\n      return Promise.reject('null nativeAuthResult');\n    }\n  }\n\n  public async signInWithFacebook(): Promise<SignInResult> {\n    const provider = new FacebookAuthProvider();\n    const authOptions: SignInWithOAuthOptions = {\n      scopes: ['email', 'public_profile']\n    };\n\n    // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n    return this.socialSignIn(provider, authOptions);\n  }\n\n  public async signInWithGoogle(): Promise<SignInResult> {\n    const provider = new GoogleAuthProvider();\n    const authOptions: SignInWithOAuthOptions = {\n      scopes: ['email', 'profile']\n    };\n\n    // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n    return this.socialSignIn(provider, authOptions);\n  }\n\n  public async signInWithTwitter(): Promise<SignInResult> {\n    const provider = new TwitterAuthProvider();\n    const authOptions: SignInWithOAuthOptions = {\n      scopes: ['email', 'name']\n    };\n\n    // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n    return this.socialSignIn(provider, authOptions);\n  }\n\n  public async signInWithApple(): Promise<SignInResult> {\n    const provider = new OAuthProvider('apple.com');\n    const authOptions: SignInWithOAuthOptions = {\n      scopes: ['email', 'name']\n    };\n\n    // ? When we use the redirect authentication flow, the code below the socialSignIn() invocation does not get executed as we leave the current page\n    return this.socialSignIn(provider, authOptions);\n  }\n\n  public async signInWithEmail(email: string, password: string): Promise<SignInResult> {\n    // ? Show a loader while we attempt to perform the login\n    this.presentLoading('email');\n\n    const auth = getAuth();\n    const credential = await signInWithEmailAndPassword(auth, email, password);\n\n    this.dismissLoading();\n\n    return this.firebaseAuthHelper.createSignInResult(credential, null);\n  }\n\n  public async signUpWithEmail(email: string, password: string): Promise<SignInResult> {\n    // ? Show a loader while we attempt to perform the signup\n    this.presentLoading('email');\n\n    const auth = getAuth();\n    const credential = await createUserWithEmailAndPassword(auth, email, password);\n\n    this.dismissLoading();\n\n    return this.firebaseAuthHelper.createSignInResult(credential, null);\n  }\n\n  public get redirectResult$(): Observable<any> {\n    return this.redirectResultSubject.asObservable();\n  }\n\n  public get authState$(): Observable<AuthStateChange> {\n    return this.authStateSubject.asObservable();\n  }\n\n  public getProfileDataSource(): Observable<FirebaseProfileModel> {\n    const auth = getAuth();\n    return of(auth.currentUser)\n    .pipe(\n      filter((user: FirebaseUser) => user != null),\n      map((user: FirebaseUser) => {\n        const userResult = this.firebaseAuthHelper.createUserResult(user);\n        return this.setUserModelForProfile(userResult);\n      })\n    );\n  }\n\n  private setUserModelForProfile(userResult?: (User | null)): FirebaseProfileModel {\n    const userModel = new FirebaseProfileModel();\n\n    if (userResult) {\n      userModel.image = this.getPhotoURL(userResult.providerId, userResult.photoUrl);\n      userModel.name = userResult.displayName || 'What\\'s your name?';\n      userModel.role = 'How would you describe yourself?';\n      userModel.description = 'Anything else you would like to share with the world?';\n      userModel.phoneNumber = userResult.phoneNumber || 'Is there a number where I can reach you?';\n      userModel.email = userResult.email || 'Where can I send you emails?';\n      userModel.provider = (userResult.providerId !== 'password') ? userResult.providerId : 'Credentials';\n    }\n\n    return userModel;\n  }\n\n  public getProfileStore(dataSource: Observable<FirebaseProfileModel>): DataStore<FirebaseProfileModel> {\n    // ? Initialize the model specifying that it is a shell model\n    const shellModel: FirebaseProfileModel = new FirebaseProfileModel();\n    this.profileDataStore = new DataStore(shellModel);\n    // ? Trigger the loading mechanism (with shell) in the dataStore\n    this.profileDataStore.load(dataSource);\n    return this.profileDataStore;\n  }\n\n  private getPhotoURL(signInProviderId: string, photoURL: string): string {\n    // ? Default imgs are too small and our app needs a bigger image\n    switch (signInProviderId) {\n      case SignInProvider.facebook:\n        return photoURL + '?height=400';\n      case SignInProvider.twitter:\n        return photoURL.replace('_normal', '_400x400');\n      case SignInProvider.google:\n        return photoURL.split('=')[0];\n      case 'password':\n        return 'https://s3-us-west-2.amazonaws.com/ionicthemes/otros/avatar-placeholder.png';\n      default:\n        return photoURL;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}