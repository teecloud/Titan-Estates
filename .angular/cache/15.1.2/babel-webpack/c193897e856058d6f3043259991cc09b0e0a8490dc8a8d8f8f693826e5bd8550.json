{"ast":null,"code":"import { of, combineLatest, ReplaySubject } from 'rxjs';\nimport { delay, map, startWith } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\nexport class ShellModel {\n  constructor() {\n    this.isShell = false;\n  }\n}\nexport class DataStore {\n  constructor(shellModel) {\n    this.shellModel = shellModel;\n    // We wait on purpose 2 secs on local environment when fetching from json to simulate the backend roundtrip.\n    // However, in production you should set this delay to 0 in the environment.prod file.\n    // eslint-disable-next-line max-len\n    this.networkDelay = environment.appShellConfig && environment.appShellConfig.networkDelay ? environment.appShellConfig.networkDelay : 0;\n    this.timeline = new ReplaySubject(1);\n  }\n  // Static function with generics\n  // (ref: https://stackoverflow.com/a/24293088/1116959)\n  // Append a shell (T & ShellModel) to every value (T) emmited to the timeline\n  static AppendShell(dataObservable, shellModel, networkDelay = 400) {\n    const delayObservable = of(true).pipe(delay(networkDelay));\n    // Assign shell flag accordingly\n    // (ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n    return combineLatest([delayObservable, dataObservable]).pipe(\n    // Dismiss unnecessary delayValue\n    map(([delayValue, dataValue]) => Object.assign(dataValue, {\n      isShell: false\n    })),\n    // Set the shell model as the initial value\n    startWith(Object.assign(shellModel, {\n      isShell: true\n    })));\n  }\n  load(dataSourceObservable, networkDelay) {\n    // eslint-disable-next-line no-shadow, @typescript-eslint/no-shadow\n    const delay = typeof networkDelay === 'number' ? networkDelay : this.networkDelay;\n    let processedDataSource;\n    // If no network delay, then don't show shell\n    if (delay === 0) {\n      processedDataSource = dataSourceObservable;\n    } else {\n      processedDataSource = DataStore.AppendShell(dataSourceObservable, this.shellModel, delay);\n    }\n    processedDataSource.subscribe(dataValue => {\n      this.timeline.next(dataValue);\n    });\n  }\n  get state() {\n    return this.timeline.asObservable();\n  }\n}","map":{"version":3,"mappings":"AAAA,SAAqBA,EAAE,EAAEC,aAAa,EAAEC,aAAa,QAAQ,MAAM;AACnE,SAASC,KAAK,EAAEC,GAAG,EAAEC,SAAS,QAAQ,gBAAgB;AACtD,SAASC,WAAW,QAAQ,gCAAgC;AAE5D,OAAM,MAAOC,UAAU;EAAvBC;IACE,YAAO,GAAG,KAAK;EACjB;;AAEA,OAAM,MAAOC,SAAS;EAQpBD,YAAoBE,UAAa;IAAb,eAAU,GAAVA,UAAU;IAP9B;IACA;IACA;IACQ,iBAAY,GAAIJ,WAAW,CAACK,cAAc,IAAIL,WAAW,CAACK,cAAc,CAACC,YAAY,GAAIN,WAAW,CAACK,cAAc,CAACC,YAAY,GAAG,CAAC;IAEpI,aAAQ,GAAkC,IAAIV,aAAa,CAAC,CAAC,CAAC;EAEjC;EAErC;EACA;EACA;EACO,OAAOW,WAAW,CAAIC,cAA6B,EAAEJ,UAAa,EAAEE,YAAY,GAAG,GAAG;IAC3F,MAAMG,eAAe,GAAGf,EAAE,CAAC,IAAI,CAAC,CAACgB,IAAI,CACnCb,KAAK,CAACS,YAAY,CAAC,CACpB;IAED;IACA;IACA,OAAOX,aAAa,CAAC,CACnBc,eAAe,EACfD,cAAc,CACf,CAAC,CAACE,IAAI;IACL;IACAZ,GAAG,CAAC,CAAC,CAACa,UAAU,EAAEC,SAAS,CAAe,KAAuBC,MAAM,CAACC,MAAM,CAACF,SAAS,EAAE;MAACG,OAAO,EAAE;IAAK,CAAC,CAAC,CAAC;IAC5G;IACAhB,SAAS,CAACc,MAAM,CAACC,MAAM,CAACV,UAAU,EAAE;MAACW,OAAO,EAAE;IAAI,CAAC,CAAC,CAAC,CACtD;EACH;EAEAC,IAAI,CAACC,oBAAmC,EAAEX,YAAqB;IAC7D;IACA,MAAMT,KAAK,GAAI,OAAOS,YAAY,KAAK,QAAQ,GAAIA,YAAY,GAAG,IAAI,CAACA,YAAY;IAEnF,IAAIY,mBAAoC;IAExC;IACA,IAAIrB,KAAK,KAAK,CAAC,EAAE;MACfqB,mBAAmB,GAAGD,oBAAoB;KAC3C,MAAM;MACLC,mBAAmB,GAAGf,SAAS,CAACI,WAAW,CAACU,oBAAoB,EAAE,IAAI,CAACb,UAAU,EAAEP,KAAK,CAAC;;IAG3FqB,mBAAmB,CAClBC,SAAS,CAAEP,SAAyB,IAAI;MACvC,IAAI,CAACQ,QAAQ,CAACC,IAAI,CAACT,SAAS,CAAC;IAC/B,CAAC,CAAC;EACJ;EAEA,IAAWU,KAAK;IACd,OAAO,IAAI,CAACF,QAAQ,CAACG,YAAY,EAAE;EACrC","names":["of","combineLatest","ReplaySubject","delay","map","startWith","environment","ShellModel","constructor","DataStore","shellModel","appShellConfig","networkDelay","AppendShell","dataObservable","delayObservable","pipe","delayValue","dataValue","Object","assign","isShell","load","dataSourceObservable","processedDataSource","subscribe","timeline","next","state","asObservable"],"sourceRoot":"","sources":["/Users/teeicloud/TitanEstates/Titan Estates/src/app/shell/data-store.ts"],"sourcesContent":["import { Observable, of, combineLatest, ReplaySubject } from 'rxjs';\nimport { delay, map, startWith } from 'rxjs/operators';\nimport { environment } from '../../environments/environment';\n\nexport class ShellModel {\n  isShell = false;\n}\n\nexport class DataStore<T> {\n  // We wait on purpose 2 secs on local environment when fetching from json to simulate the backend roundtrip.\n  // However, in production you should set this delay to 0 in the environment.prod file.\n  // eslint-disable-next-line max-len\n  private networkDelay = (environment.appShellConfig && environment.appShellConfig.networkDelay) ? environment.appShellConfig.networkDelay : 0;\n\n  private timeline: ReplaySubject<T & ShellModel> = new ReplaySubject(1);\n\n  constructor(private shellModel: T) { }\n\n  // Static function with generics\n  // (ref: https://stackoverflow.com/a/24293088/1116959)\n  // Append a shell (T & ShellModel) to every value (T) emmited to the timeline\n  public static AppendShell<T>(dataObservable: Observable<T>, shellModel: T, networkDelay = 400): Observable<T & ShellModel> {\n    const delayObservable = of(true).pipe(\n      delay(networkDelay)\n    );\n\n    // Assign shell flag accordingly\n    // (ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n    return combineLatest([\n      delayObservable,\n      dataObservable\n    ]).pipe(\n      // Dismiss unnecessary delayValue\n      map(([delayValue, dataValue]: [boolean, T]): (T & ShellModel) => Object.assign(dataValue, {isShell: false})),\n      // Set the shell model as the initial value\n      startWith(Object.assign(shellModel, {isShell: true}))\n    );\n  }\n\n  load(dataSourceObservable: Observable<T>, networkDelay?: number): void {\n    // eslint-disable-next-line no-shadow, @typescript-eslint/no-shadow\n    const delay = (typeof networkDelay === 'number') ? networkDelay : this.networkDelay;\n\n    let processedDataSource: Observable<any>;\n\n    // If no network delay, then don't show shell\n    if (delay === 0) {\n      processedDataSource = dataSourceObservable;\n    } else {\n      processedDataSource = DataStore.AppendShell(dataSourceObservable, this.shellModel, delay);\n    }\n\n    processedDataSource\n    .subscribe((dataValue: T & ShellModel) => {\n      this.timeline.next(dataValue);\n    });\n  }\n\n  public get state(): Observable<T & ShellModel> {\n    return this.timeline.asObservable();\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}