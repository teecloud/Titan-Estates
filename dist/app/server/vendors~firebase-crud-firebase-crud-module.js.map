{"version":3,"sources":["./node_modules/@angular/fire/__ivy_ngcc__/fesm2015/angular-fire-firestore.js","./node_modules/firebase/firestore/dist/index.cjs.js"],"names":[],"mappings":";;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0I;AAC9E;AACE;AACmF;AAC9F;AACd;AACmB;AAC5B;;AAE5B;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACwC;AACxC,mCAAmC,mDAAc;AACjD,eAAe,+CAAU;AACzB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,cAAc,0DAAG;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,wCAAwC,0DAAG;AAC3C,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,iBAAiB,yBAAyB;AAC1C;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,cAAc,0DAAG;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,2BAA2B,EAAE,MAAM,qCAAqC;AACxE;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,cAAc,0DAAG;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,+CAA+C,2DAAI;AACnD,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,0EAA0E,0DAAG;AAC7E,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,sBAAsB,EAAE,MAAM,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,+EAA+E,0DAAG;AAClF,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,wDAAwD,6DAAM;AAC9D,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,8CAA8C,2DAAI;AAClD,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA,6BAA6B;AAC7B;AACA,kBAAkB,0DAAG;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,mCAAmC,EAAE,mCAAmC,cAAc,EAAE,mBAAmB,0BAA0B;AACrI;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,eAAe,iDAAI,+BAA+B,gEAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,WAAW,EAaV;;AAED;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,2CAA2C,0DAAG;AAC9C,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,eAAe,iDAAI,6BAA6B,gEAAS;AACzD;AACA;AACA,WAAW,EAQV;;AAED;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAG;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,wDAAwD,6DAAM;AAC9D,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,8CAA8C,2DAAI;AAClD,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,kBAAkB,0DAAG;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,gBAAgB;AAChB;AACA;AACA,eAAe,iDAAI,+BAA+B,gEAAS;AAC3D;AACA;AACA,WAAW,EAWV;;AAED;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B,4DAAc;AAC7C,WAAW,EAAE;AACb,iCAAiC,4DAAc;AAC/C,WAAW,EAAE;AACb,qBAAqB,4DAAc;AACnC;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd;AACA;AACA,UAAU,aAAa;AACvB;AACA,IAAI;AACJ,YAAY;AACZ;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,yEAAyE;AACpF,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA,8BAA8B,oEAAsB;AACpD,sCAAsC,oFAA8B;AACpE;AACA,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB,yEAAmB;AAC3C;AACA;AACA;AACA,gBAAgB,qEAAiB;AACjC,gBAAgB,6EAA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EAAE,iCAAiC;AAC5L,4BAA4B,CAAC,+DAAwB;AACrD,cAAc,sDAAQ;AACtB;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,WAAW,EAQV;AACD;AACA;AACA;AACA,yCAAyC;AACzC,WAAW,EAcV;AACD;AACA;AACA;AACA;AACA,kCAAkC;AAClC,WAAW,EAMV;AACD;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,WAAW,EAGV;AACD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,WAAW,EAGV;AACD;AACA;AACA;AACA;AACA,iCAAiC;AACjC,WAAW,EAKV;AACD;AACA;AACA;AACA;AACA,mBAAmB;AACnB,WAAW,EAKV;AACD;AACA;AACA;AACA;AACA,sBAAsB;AACtB,WAAW,EAGV;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gCAAgC;AAChC,WAAW,EAKV;;AAED;AACA;AACA,cAAc,uFAAuF;AACrG;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;;AAEsU;;AAEtU,kD;;;;;;;;;;;;ACnjCa;;AAEb,mBAAO,CAAC,iCAAqB;;AAE7B","file":"vendors~firebase-crud-firebase-crud-module.js","sourcesContent":["import { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, from, of } from 'rxjs';\nimport { map, scan, filter, observeOn } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport firebase from '@firebase/app';\nimport { registerFirestore } from '@firebase/firestore';\nimport 'firebase/firestore';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T, R\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\nimport * as ɵngcc0 from '@angular/core';\nfunction _fromRef(ref, scheduler = asyncScheduler) {\n    return new Observable((/**\n     * @param {?} subscriber\n     * @return {?}\n     */\n    subscriber => {\n        /** @type {?} */\n        let unsubscribe;\n        if (scheduler != null) {\n            scheduler.schedule((/**\n             * @return {?}\n             */\n            () => {\n                unsubscribe = ref.onSnapshot(subscriber);\n            }));\n        }\n        else {\n            unsubscribe = ref.onSnapshot(subscriber);\n        }\n        return (/**\n         * @return {?}\n         */\n        () => {\n            if (unsubscribe != null) {\n                unsubscribe();\n            }\n        });\n    }));\n}\n/**\n * @template R\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\nfunction fromRef(ref, scheduler) {\n    return _fromRef(ref, scheduler);\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\nfunction fromDocRef(ref, scheduler) {\n    return fromRef(ref, scheduler)\n        .pipe(map((/**\n     * @param {?} payload\n     * @return {?}\n     */\n    payload => ({ payload, type: 'value' }))));\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\nfunction fromCollectionRef(ref, scheduler) {\n    return fromRef(ref, scheduler).pipe(map((/**\n     * @param {?} payload\n     * @return {?}\n     */\n    payload => ({ payload, type: 'query' }))));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @template T\n * @param {?} query\n * @param {?=} scheduler\n * @return {?}\n */\nfunction docChanges(query, scheduler) {\n    return fromCollectionRef(query, scheduler)\n        .pipe(map((/**\n     * @param {?} action\n     * @return {?}\n     */\n    action => action.payload.docChanges()\n        .map((/**\n     * @param {?} change\n     * @return {?}\n     */\n    change => ((/** @type {?} */ ({ type: change.type, payload: change }))))))));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @template T\n * @param {?} query\n * @param {?} events\n * @param {?=} scheduler\n * @return {?}\n */\nfunction sortedChanges(query, events, scheduler) {\n    return fromCollectionRef(query, scheduler)\n        .pipe(map((/**\n     * @param {?} changes\n     * @return {?}\n     */\n    changes => changes.payload.docChanges())), scan((/**\n     * @param {?} current\n     * @param {?} changes\n     * @return {?}\n     */\n    (current, changes) => combineChanges(current, changes, events)), []), map((/**\n     * @param {?} changes\n     * @return {?}\n     */\n    changes => changes.map((/**\n     * @param {?} c\n     * @return {?}\n     */\n    c => ((/** @type {?} */ ({ type: c.type, payload: c }))))))));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @template T\n * @param {?} current\n * @param {?} changes\n * @param {?} events\n * @return {?}\n */\nfunction combineChanges(current, changes, events) {\n    changes.forEach((/**\n     * @param {?} change\n     * @return {?}\n     */\n    change => {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = combineChange(current, change);\n        }\n    }));\n    return current;\n}\n/**\n * Creates a new sorted array from a new change.\n * @template T\n * @param {?} combined\n * @param {?} change\n * @return {?}\n */\nfunction combineChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n                // Not sure why the duplicates are getting fired\n            }\n            else {\n                combined.splice(change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    combined.splice(change.oldIndex, 1);\n                    combined.splice(change.newIndex, 0, change);\n                }\n                else {\n                    combined.splice(change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n                combined.splice(change.oldIndex, 1);\n            }\n            break;\n    }\n    return combined;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?=} events\n * @return {?}\n */\nfunction validateEventsArray(events) {\n    if (!events || events.length === 0) {\n        events = ['added', 'removed', 'modified'];\n    }\n    return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\nclass AngularFirestoreCollection {\n    /**\n     * The constructor takes in a CollectionReference and Query to provide wrapper methods\n     * for data operations and data streaming.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query. See the AssociatedRefence type for details\n     * on this implication.\n     * @param {?} ref\n     * @param {?} query\n     * @param {?} afs\n     */\n    constructor(ref, query, afs) {\n        this.ref = ref;\n        this.query = query;\n        this.afs = afs;\n    }\n    /**\n     * Listen to the latest change in the stream. This method returns changes\n     * as they occur and they are not sorted by query order. This allows you to construct\n     * your own data structure.\n     * @param {?=} events\n     * @return {?}\n     */\n    stateChanges(events) {\n        if (!events || events.length === 0) {\n            return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);\n        }\n        return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map((/**\n         * @param {?} actions\n         * @return {?}\n         */\n        actions => actions.filter((/**\n         * @param {?} change\n         * @return {?}\n         */\n        change => events.indexOf(change.type) > -1)))), filter((/**\n         * @param {?} changes\n         * @return {?}\n         */\n        changes => changes.length > 0)), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     * @param {?=} events\n     * @return {?}\n     */\n    auditTrail(events) {\n        return this.stateChanges(events).pipe(scan((/**\n         * @param {?} current\n         * @param {?} action\n         * @return {?}\n         */\n        (current, action) => [...current, ...action]), []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     * @param {?=} events\n     * @return {?}\n     */\n    snapshotChanges(events) {\n        /** @type {?} */\n        const validatedEvents = validateEventsArray(events);\n        /** @type {?} */\n        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n        return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * @template K\n     * @param {?=} options\n     * @return {?}\n     */\n    valueChanges(options = {}) {\n        return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular)\n            .pipe(map((/**\n         * @param {?} actions\n         * @return {?}\n         */\n        actions => actions.payload.docs.map((/**\n         * @param {?} a\n         * @return {?}\n         */\n        a => {\n            if (options.idField) {\n                return (/** @type {?} */ (Object.assign(Object.assign({}, (/** @type {?} */ (a.data()))), { [options.idField]: a.id })));\n            }\n            else {\n                return a.data();\n            }\n        })))), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     * @param {?=} options\n     * @return {?}\n     */\n    get(options) {\n        return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n    /**\n     * Add data to a collection reference.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query.\n     * @param {?} data\n     * @return {?}\n     */\n    add(data) {\n        return this.ref.add(data);\n    }\n    /**\n     * Create a reference to a single document in a collection.\n     * @template T\n     * @param {?=} path\n     * @return {?}\n     */\n    doc(path) {\n        return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n    }\n}\nif (false) {\n    /** @type {?} */\n    AngularFirestoreCollection.prototype.ref;\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFirestoreCollection.prototype.query;\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFirestoreCollection.prototype.afs;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n * @template T\n */\nclass AngularFirestoreDocument {\n    /**\n     * The contstuctor takes in a DocumentReference to provide wrapper methods\n     * for data operations, data streaming, and Symbol.observable.\n     * @param {?} ref\n     * @param {?} afs\n     */\n    constructor(ref, afs) {\n        this.ref = ref;\n        this.afs = afs;\n    }\n    /**\n     * Create or overwrite a single document.\n     * @param {?} data\n     * @param {?=} options\n     * @return {?}\n     */\n    set(data, options) {\n        return this.ref.set(data, options);\n    }\n    /**\n     * Update some fields of a document without overwriting the entire document.\n     * @param {?} data\n     * @return {?}\n     */\n    update(data) {\n        return this.ref.update(data);\n    }\n    /**\n     * Delete a document.\n     * @return {?}\n     */\n    delete() {\n        return this.ref.delete();\n    }\n    /**\n     * Create a reference to a sub-collection given a path and an optional query\n     * function.\n     * @template R\n     * @param {?} path\n     * @param {?=} queryFn\n     * @return {?}\n     */\n    collection(path, queryFn) {\n        /** @type {?} */\n        const collectionRef = this.ref.collection(path);\n        const { ref, query } = associateQuery(collectionRef, queryFn);\n        return new AngularFirestoreCollection(ref, query, this.afs);\n    }\n    /**\n     * Listen to snapshot updates from the document.\n     * @return {?}\n     */\n    snapshotChanges() {\n        /** @type {?} */\n        const scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n        return scheduledFromDocRef$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Listen to unwrapped snapshot updates from the document.\n     * @return {?}\n     */\n    valueChanges() {\n        return this.snapshotChanges().pipe(map((/**\n         * @param {?} action\n         * @return {?}\n         */\n        action => {\n            return action.payload.data();\n        })));\n    }\n    /**\n     * Retrieve the document once.\n     * @param {?=} options\n     * @return {?}\n     */\n    get(options) {\n        return from(this.ref.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n}\nif (false) {\n    /** @type {?} */\n    AngularFirestoreDocument.prototype.ref;\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFirestoreDocument.prototype.afs;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\nclass AngularFirestoreCollectionGroup {\n    /**\n     * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n     * for data operations and data streaming.\n     * @param {?} query\n     * @param {?} afs\n     */\n    constructor(query, afs) {\n        this.query = query;\n        this.afs = afs;\n    }\n    /**\n     * Listen to the latest change in the stream. This method returns changes\n     * as they occur and they are not sorted by query order. This allows you to construct\n     * your own data structure.\n     * @param {?=} events\n     * @return {?}\n     */\n    stateChanges(events) {\n        if (!events || events.length === 0) {\n            return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);\n        }\n        return docChanges(this.query, this.afs.schedulers.outsideAngular)\n            .pipe(map((/**\n         * @param {?} actions\n         * @return {?}\n         */\n        actions => actions.filter((/**\n         * @param {?} change\n         * @return {?}\n         */\n        change => events.indexOf(change.type) > -1)))), filter((/**\n         * @param {?} changes\n         * @return {?}\n         */\n        changes => changes.length > 0)), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     * @param {?=} events\n     * @return {?}\n     */\n    auditTrail(events) {\n        return this.stateChanges(events).pipe(scan((/**\n         * @param {?} current\n         * @param {?} action\n         * @return {?}\n         */\n        (current, action) => [...current, ...action]), []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     * @param {?=} events\n     * @return {?}\n     */\n    snapshotChanges(events) {\n        /** @type {?} */\n        const validatedEvents = validateEventsArray(events);\n        /** @type {?} */\n        const scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n        return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Listen to all documents in the collection and its possible query as an Observable.\n     * @return {?}\n     */\n    valueChanges() {\n        /** @type {?} */\n        const fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n        return fromCollectionRefScheduled$\n            .pipe(map((/**\n         * @param {?} actions\n         * @return {?}\n         */\n        actions => actions.payload.docs.map((/**\n         * @param {?} a\n         * @return {?}\n         */\n        a => a.data())))), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     * @param {?=} options\n     * @return {?}\n     */\n    get(options) {\n        return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFirestoreCollectionGroup.prototype.query;\n    /**\n     * @type {?}\n     * @private\n     */\n    AngularFirestoreCollectionGroup.prototype.afs;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n * @type {?}\n */\nconst ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\n/** @type {?} */\nconst PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\n/** @type {?} */\nconst SETTINGS = new InjectionToken('angularfire2.firestore.settings');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param {?} collectionRef - A collection reference to query\n * @param {?=} queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n * @return {?}\n */\nfunction associateQuery(collectionRef, queryFn = (/**\n * @param {?} ref\n * @return {?}\n */\nref => ref)) {\n    /** @type {?} */\n    const query = queryFn(collectionRef);\n    /** @type {?} */\n    const ref = collectionRef;\n    return { query, ref };\n}\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '\\@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '\\@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * \\@Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\nclass AngularFirestore {\n    /**\n     * Each Feature of AngularFire has a FirebaseApp injected. This way we\n     * don't rely on the main Firebase App instance and we can create named\n     * apps and use multiple apps.\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} shouldEnablePersistence\n     * @param {?} settings\n     * @param {?} platformId\n     * @param {?} zone\n     * @param {?} persistenceSettings\n     */\n    constructor(options, nameOrConfig, shouldEnablePersistence, settings, \n    // tslint:disable-next-line:ban-types\n    platformId, zone, persistenceSettings) {\n        this.schedulers = new ɵAngularFireSchedulers(zone);\n        this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n        this.firestore = zone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n            // INVESTIGATE this seems to be required because in the browser build registerFirestore is an Object?\n            //             seems like we're fighting ngcc. In the server firestore() isn't available, so I have to register\n            //             in the browser registerFirestore is not a function... maybe this is an underlying firebase-js-sdk issue\n            if (registerFirestore) {\n                registerFirestore(firebase);\n            }\n            /** @type {?} */\n            const firestore = app.firestore();\n            if (settings) {\n                firestore.settings(settings);\n            }\n            return firestore;\n        }));\n        if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n            // We need to try/catch here because not all enablePersistence() failures are caught\n            // https://github.com/firebase/firebase-js-sdk/issues/608\n            /** @type {?} */\n            const enablePersistence = (/**\n             * @return {?}\n             */\n            () => {\n                try {\n                    return from(this.firestore.enablePersistence(persistenceSettings || undefined).then((/**\n                     * @return {?}\n                     */\n                    () => true), (/**\n                     * @return {?}\n                     */\n                    () => false)));\n                }\n                catch (e) {\n                    return of(false);\n                }\n            });\n            this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);\n        }\n        else {\n            this.persistenceEnabled$ = of(false);\n        }\n    }\n    /**\n     * @template T\n     * @param {?} pathOrRef\n     * @param {?=} queryFn\n     * @return {?}\n     */\n    collection(pathOrRef, queryFn) {\n        /** @type {?} */\n        let collectionRef;\n        if (typeof pathOrRef === 'string') {\n            collectionRef = this.firestore.collection(pathOrRef);\n        }\n        else {\n            collectionRef = pathOrRef;\n        }\n        const { ref, query } = associateQuery(collectionRef, queryFn);\n        /** @type {?} */\n        const refInZone = this.schedulers.ngZone.run((/**\n         * @return {?}\n         */\n        () => ref));\n        return new AngularFirestoreCollection(refInZone, query, this);\n    }\n    /**\n     * Create a reference to a Firestore Collection Group based on a collectionId\n     * and an optional query function to narrow the result\n     * set.\n     * @template T\n     * @param {?} collectionId\n     * @param {?=} queryGroupFn\n     * @return {?}\n     */\n    collectionGroup(collectionId, queryGroupFn) {\n        /** @type {?} */\n        const queryFn = queryGroupFn || ((/**\n         * @param {?} ref\n         * @return {?}\n         */\n        ref => ref));\n        /** @type {?} */\n        const collectionGroup = this.firestore.collectionGroup(collectionId);\n        return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n    }\n    /**\n     * @template T\n     * @param {?} pathOrRef\n     * @return {?}\n     */\n    doc(pathOrRef) {\n        /** @type {?} */\n        let ref;\n        if (typeof pathOrRef === 'string') {\n            ref = this.firestore.doc(pathOrRef);\n        }\n        else {\n            ref = pathOrRef;\n        }\n        /** @type {?} */\n        const refInZone = this.schedulers.ngZone.run((/**\n         * @return {?}\n         */\n        () => ref));\n        return new AngularFirestoreDocument(refInZone, this);\n    }\n    /**\n     * Returns a generated Firestore Document Id.\n     * @return {?}\n     */\n    createId() {\n        return this.firestore.collection('_').doc().id;\n    }\n}\nAngularFirestore.ɵfac = function AngularFirestore_Factory(t) { return new (t || AngularFirestore)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(ENABLE_PERSISTENCE, 8), ɵngcc0.ɵɵinject(SETTINGS, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PERSISTENCE_SETTINGS, 8)); };\n/** @nocollapse */\nAngularFirestore.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ENABLE_PERSISTENCE,] }] },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SETTINGS,] }] },\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [PERSISTENCE_SETTINGS,] }] }\n];\n/** @nocollapse */ AngularFirestore.ɵprov = ɵɵdefineInjectable({ factory: function AngularFirestore_Factory() { return new AngularFirestore(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(ENABLE_PERSISTENCE, 8), ɵɵinject(SETTINGS, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(PERSISTENCE_SETTINGS, 8)); }, token: AngularFirestore, providedIn: \"any\" });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFirestore, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'any'\n            }]\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [FIREBASE_OPTIONS]\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [FIREBASE_APP_NAME]\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [ENABLE_PERSISTENCE]\n            }] }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [SETTINGS]\n            }] }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\n                type: Optional\n            }, {\n                type: Inject,\n                args: [PERSISTENCE_SETTINGS]\n            }] }]; }, null); })();\nif (false) {\n    /** @type {?} */\n    AngularFirestore.prototype.firestore;\n    /** @type {?} */\n    AngularFirestore.prototype.persistenceEnabled$;\n    /** @type {?} */\n    AngularFirestore.prototype.schedulers;\n    /** @type {?} */\n    AngularFirestore.prototype.keepUnstableUntilFirst;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AngularFirestoreModule {\n    /**\n     * Attempt to enable persistent storage, if possible\n     * @param {?=} persistenceSettings\n     * @return {?}\n     */\n    static enablePersistence(persistenceSettings) {\n        return {\n            ngModule: AngularFirestoreModule,\n            providers: [\n                { provide: ENABLE_PERSISTENCE, useValue: true },\n                { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n            ]\n        };\n    }\n}\nAngularFirestoreModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AngularFirestoreModule });\nAngularFirestoreModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function AngularFirestoreModule_Factory(t) { return new (t || AngularFirestoreModule)(); }, providers: [AngularFirestore] });\n/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AngularFirestoreModule, [{\n        type: NgModule,\n        args: [{\n                providers: [AngularFirestore]\n            }]\n    }], null, null); })();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n * @template T\n */\nfunction DocumentSnapshotExists() { }\nif (false) {\n    /** @type {?} */\n    DocumentSnapshotExists.prototype.exists;\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    DocumentSnapshotExists.prototype.data = function (options) { };\n}\n/**\n * @record\n */\nfunction DocumentSnapshotDoesNotExist() { }\nif (false) {\n    /** @type {?} */\n    DocumentSnapshotDoesNotExist.prototype.exists;\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    DocumentSnapshotDoesNotExist.prototype.data = function (options) { };\n    /**\n     * @param {?} fieldPath\n     * @param {?=} options\n     * @return {?}\n     */\n    DocumentSnapshotDoesNotExist.prototype.get = function (fieldPath, options) { };\n}\n/**\n * @record\n * @template T\n */\nfunction QueryDocumentSnapshot() { }\nif (false) {\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    QueryDocumentSnapshot.prototype.data = function (options) { };\n}\n/**\n * @record\n * @template T\n */\nfunction QuerySnapshot() { }\nif (false) {\n    /** @type {?} */\n    QuerySnapshot.prototype.docs;\n}\n/**\n * @record\n * @template T\n */\nfunction DocumentChange() { }\nif (false) {\n    /** @type {?} */\n    DocumentChange.prototype.doc;\n}\n/**\n * @record\n * @template T\n */\nfunction DocumentChangeAction() { }\nif (false) {\n    /** @type {?} */\n    DocumentChangeAction.prototype.type;\n    /** @type {?} */\n    DocumentChangeAction.prototype.payload;\n}\n/**\n * @record\n * @template T\n */\nfunction Action() { }\nif (false) {\n    /** @type {?} */\n    Action.prototype.type;\n    /** @type {?} */\n    Action.prototype.payload;\n}\n/**\n * @record\n * @template T\n */\nfunction Reference() { }\nif (false) {\n    /** @type {?} */\n    Reference.prototype.onSnapshot;\n}\n/**\n * A structure that provides an association between a reference\n * and a query on that reference. Note: Performing operations\n * on the reference can lead to confusing results with complicated\n * queries.\n *\n * Example:\n *\n * const query = ref.where('type', '==', 'Book').\n *                  .where('price', '>' 18.00)\n *                  .where('price', '<' 100.00)\n *                  .where('category', '==', 'Fiction')\n *                  .where('publisher', '==', 'BigPublisher')\n *\n * // This addition would not be a result of the query above\n * ref.add({\n *  type: 'Magazine',\n *  price: 4.99,\n *  category: 'Sports',\n *  publisher: 'SportsPublisher'\n * });\n * @record\n */\nfunction AssociatedReference() { }\nif (false) {\n    /** @type {?} */\n    AssociatedReference.prototype.ref;\n    /** @type {?} */\n    AssociatedReference.prototype.query;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };\n\n//# sourceMappingURL=angular-fire-firestore.js.map","'use strict';\n\nrequire('@firebase/firestore');\n\n//# sourceMappingURL=index.cjs.js.map\n"],"sourceRoot":"webpack:///"}